"use strict";

/**
 *  В этом уроке более подробно разбирается такое понятие как замыкание функций и лексическое окружение.
 *  ---
 *  JavaScript – довольно гибкий язык программирования: можно в любой момент создавать переменные, функции и
 *  вложенные функции, передавать их как аргументы и т.д.
 *  Чтобы не запутаться в таких операциях, нужен определённый механизм контроля, ведь на практике возникает
 *  огромное количество операций, особенно когда переменные, с которыми работают функции, активно изменяются.
 *  ---
 *  Рассмотрим небольшой пример:
 */
let number = 5;
// Объявление функции Function Declaration – оно создана ещё до того, как код начал выполняться построчно.
function logNumber() {
    console.log(number);
}
number = 6;

logNumber(); // -> 6, потомучто !!! Функция всегда получает текущее (последнее) значение внешних переменных.

/**
 *  Лексическое окружение (Lexical Environment) – это внутренний технический скрытый объект. Существует у
 *  любого блока кода, ограниченного фигурными скобками {...}
 *  Оно делится на две части – внутренне и внешнее окружение.
 *  1) Внутреннее лексическое окружение (Environment Record) – это объект, в котором, как свойства, хранятся все
 *  локальные переменные и значения this.
 *  2) Внешнее лексическое окружение – это объект, который соответствует коду "снаружи".
 *  ---
 *  !! Любая переменная – это свойство объекта лексического окружения.
 */

/**
 *  Порядок выполнения функции:
 *  1) Сначала она была создана и в какой-то момент она вызывается в коде.
 *  2) Функция создаёт внутри себя те переменные, которые в ней были прописаны.
 *  3) Идёт вызов и создание внутреннего и внешного (глобального) лексического окружения.
 *  4) Присвоение значений, которые были записаны в переменных.
 *  5) Процессы происходят до тех пор, пока не будет вызвана первая команда, которая работает с чем-либо, например,
 *     console.log(number).
 *  6) Функция полностью отработала, вернула что-либо.
 *  7) Лексическое окружение функции за ненадобнотъю полностью уничтожается.
 */

/**
 *  !! Каждый вызов функции – это создание нового лексического окружения со своими специфичными для этого вызова
 *     локальными переменными и параметрами.
 */
number = 8;
/**
 *   У глобального лексического окружения конкретно этого вызова функции будет уже стоять свойство number = 8,
 *   а не number = 6, как у предыдущего вызова.
 */
logNumber(); // -> 8

/**
 *  Самое сложное начинается тогда, когда идёт комбинация функций, в том числе возврат из функции другой
 *  функции. Логика остаётся точно такая же – у каждой функции будет своё глобальное и лексическое окружение.
 *  Например, функции со счётчиками, их дают на собеседованиях.
 */
function createCounter() {
    let counter = 0;
    /**
     *  Даже когда функция myFunction() уничтожает своё лексическое окружение, она продолжает хранить ссылку на
     *  переменную counter. Всё это сохраняется на переменную increment, в том числе и замыкание этой функции.
     *  Тоесть, в данном случае, мы имеем постепенное увеличение значения counter на +1.
     *  ---
     *  Замыкание - это функция, которая запоминает свои внешние переменные и может получить к ним доступ.
     */
    const myFunction = function() {
        counter = counter + 1;
        return counter;
    };
    /**
     *  Итог: когда функция myFunction() создаётся, она сохраняет ссылки на сущности, которые были ей доступны во
     *  время создания.
     */

    return myFunction; // Тут функция возвращает вторую функцию.
}
const increment = createCounter();
const c1 = increment(); // -> 1
const c2 = increment(); // -> 2
const c3 = increment(); // -> 3

console.log(c1, c2, c3); // -> 1 2 3

/**
 *  + Один из вопросов на собеседованиях: "почему нельзя вывести переменную num"?
 *    Это всё к тому, что лексическое окружение создаётся внутри любых фигурных скобок, в том числе и в циклах.
 */
for (let i = 0; i < 9; i++) {
    for (let j = 0; j < 9; j++) {
        let num = 3;
    }
    console.log(num); // -> Нельзя получить, ибо num находится во внутреннем лексическом окружении вложенного цикла.
}