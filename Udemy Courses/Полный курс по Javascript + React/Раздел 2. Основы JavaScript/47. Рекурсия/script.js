'use strict';

/**
 *  В этом уроке обсуждается приём, который используется в программировании в целом – рекурсия.
 *  Это приём, когда функция вызывает сама себя.
 *  ---
 *  Типичный пример рекурсии – это функция возведения в степень.
 * 
 *  Данную задачу можно реализовать двумя способами, один из которых проявляется в применении цикла:
 */
function pow(x, n) {
	let result = 1;

	for (let i = 0; i < n; i++) {
		result *= x; // -> *= - оператор дополнительного умножения. То же самое, что и result = x * result
	}

	return result; 
}
pow(2, 1); // -> 2
pow(2, 2); // -> 4
pow(2, 3); // -> 8

// Что будет, если вместо цикла запускать саму же функцию pow()?
function powRecursion(x, n) {
	if (n === 1) {
		return x; // -> если степень равна 1, вернуть базу с помощью входящего аргумента x.
	} else {
		return x * powRecursion(x, n - 1);
		/**
         *  При передаче x = 2, n = 2, они в том числе подставяются во внутреннюю функцию, где получится
         *  результат 2 в первой степени. По итогу выйдет 2 * 2 = 4.
         *  ---
         *  Эта команда вычисляет то же самое, только на одну степень меньше. Когда будет много степеней, то
         *  будет вложенность функций – одна будет вызывать другую -> другую -> другую до тех пор, пока
         *  всё это дерево функций не выйдет на условие n === 1, где возвратом будет только единица.
         *  ---
         *  В конечном счёте, рекурсия используется не только для математических вычислений. В этом уроке также
         *  будут рассмотрены иные примеры с рекурсией.
         */
	}
}
powRecursion(2, 1); // -> 2
powRecursion(2, 2); // -> 4
powRecursion(2, 3); // -> 8

/**
 *  Главные термины, которые относятся к рекурсии:
 *  1) База рекурсии - это случай, который приводит сразу к завершению функции, например, число 1;
 *  2) Шаг рекурсии – это запуск вложенной функции, но уже с другим значением;
 *  3) Глубина рекурсии – это общее количество вложенных вызовов вместе с самым первым;
 *  4) Максимальная глубина рекурсии – это насколько рекурсия может углубиться саму в себя. Она может варьироваться
 *  от сложности действий и возможностей ПК (в среднем 10.000 шагов).
 */

/**
 *  Что лучше использовать: перебор через цикл или рекурсию? Существует несколько аспектов:
 *  - Итеративный подход (через цикл) обычно эффективнее. Это связанно с внутренним устройством языка и с
 *  такими вещами как контекст и стэк вызова.
 *  - Рекурсия делает функции проще, хоть и имеет свои ограничения по глубине.
 *  - У каждого свои предпочтения и любимые приёмы, но большинство программистов склоняется к рекурсии.
 *  
 *  Ниже приведён пример, почему рекурсия удобнее итеративного подхода:
 */

// База данных со студентами двух курсов (html и js). Информация структурированна во вложенных объектах и массивах.
let students = {
	js: [{
		name: 'John',
		progress: 100
	}, {
		name: 'Ivan',
		progress: 60
	}],

	html: {
		basic: [{
			name: 'Peter',
			progress: 20
		}, {
			name: 'Ann',
			progress: 18
		}],

		pro: [{
			name: 'Sam',
			progress: 10
		}]
	}
};

/**
 *  Необходимо получить следующую информацию:
 *  1) Сколько студентов находится на всех курсах;
 *  2) Их общее число прогресса;
 *  3) Средний прогресс всех студентов.
 *  ---
 *  Реализация данной задачи с помощью итеративного подхода:
 */

function getTotalProgressByIteration(data) {
	let total = 0;
	let students = 0;
	/**
     *  Метод Object.values() – получить массив значений перечисляемых свойств объекта в том же порядке,
     *  что и с помощью цикла for-in.
     */
	for (let course of Object.values(data)) {
		if ( Array.isArray(course) ) { // Метод Array.isArray() – проверить, является ли элемент массивом.
			students += course.length;
			for (let i = 0; i < course.length; i++) {
				total += course[i].progress; 
			}
		} else {
			for (let subCourse of Object.values(course)) {
				students += subCourse.length;
				for (let i = 0; i < subCourse.length; i++) {
					total += subCourse[i].progress; 
				}
			}
		}
	}
    
	return total / students;
}
console.log( getTotalProgressByIteration(students) ); // -> 41.6

/**
 *  Решение задачи выше подойдёт только для данных с чёткой структурой, которая вписывается в условие (массив / объект).
 *  Он не сработает, если структура будет иметь вложенности поглубже или нарушится порядок размещения массивов и объектов.
 *  ---
 *  Чтобы таких моментов не возникало, можно использовать рекурсию, которая, проработав все возможные исходы, сделает всё
 *  за нас:
 */

function getTotalProgressByRecursion(data) {
	/**
     *  В рекурсии, в отличии от итеративного подхода, не существует промежуточных переменных, так как значение по факту
     *  пересчитывается во вложенной функции.
     *  Например, в итеративном варианте на этом месте была переменная students, которой тут не будет.
     */

	if ( Array.isArray(data) ) {
		/**
         *  В качестве базы рекурсии был выбран массив, так как, по логике структуры, он будет в конечном счёте являться
         *  последним элементом вычислений.
         */
		let total = 0;

		for (let i = 0; i < data.length; i++) {
			total += data[i].progress;
		}

		return [total, data.length]; // -> С помощью команды return можно возвращать любую информацию, в том числе массивы.
	} else {
		let total = [0, 0];

		for (let subData of Object.values(data)) {
			const subDataArr = getTotalProgressByRecursion(subData);
			/**
             *  С данной вложенной функции n-ое количество раз будет получен массив [total, data.length], значения которого
             *  дополнительно присваиваются в переменную условия else.
             *  P.S. Вложенная функция принимает в себя массивы, которые в этой условной вилке извлекаются из объекта при
             *  помощи метода Object.values() и его конструкции for-of.
             */
			total[0] += subDataArr[0];
			total[1] += subDataArr[1];
		}

		return total;
	}
}

/**
 *  Если функция возвращает массив и нужно сделать конкретные манипуляции одного элемента массива над другим, допустимо
 *  выполнить такие действия:
 */
const result = getTotalProgressByRecursion(students);
console.log( result[0] / result[1] ); // -> 41.6, где result[0] – общее число прогресса, а result[1] – количество студентов.