'use strict';

/**
 *  В этом уроке обсуждается одна из важнейших тем в JavaScript, до которой многие новички просто
 *  не доживают, теряясь в куче теоретической информации.
 *  Это про то, как взаимодействовать с элементами на странице. Для этого существует такое понятие
 *  как событие.
 *  ---
 *  Событие – это сигнал от браузера о том, что что-то произошло. Например, клик, двойной клик,
 *  наведение мыши, убрать мышь с элемента, прокрутка колёсика мышки, отправка данных в форме,
 *  нажатие определённых клавиш на клавиатуре и многое другое.
 *  ---
 *  Всё, чем занимается пользователь на странице, и есть события. Их можно отлавливать.
 */

/**
 *  Чтобы использовать любое событие, необходимо назначить его обработчик.
 *  ---
 *  Обработчик – это функция, которая срабатывает, как только событие произошло.
 * 
 *  Всего в JavaScript существует 3 способа назначения обработчика событий:
 * 
 *  1) Использовать HTML-атрибут, который записывается прямо в вёрстке. В этот атрибут можно передать
 *     функцию прямо из скриптового файла.
 *     !! Смотреть файл index.html
 * 
 *  2) Использовать свойства DOM-дерева для событий, например, свойство onclick.
 *     Но в реальных проектах такой подход тоже почти не используется. У него есть одна большая проблема:
 *     ~ Если такое свойство повторить в коде несколько раз, то будет выводиться только последнее
 *       записанное в коде действие.
 *     ~ Удалить этот обработчик событий нельзя. После своего выполнения он так и остаётся активным.
 */
const btns = document.querySelectorAll('button');
btns[1].onclick = function() {
	alert('Клик с помощью свойства DOM-дерева успешно сработал!');
};

/**
 *  3) C помощью методов addEventListener() и removeEventListener().
 *     ---
 *     Метод addEventListener – добавить слушатель за событиями. Если произойдёт определённое событие,
 *     то запустится его обработчик.
 * 
 *     Метод вмещает в себя 3 аргумента:
 *     1. Название события, например, click.
 *     2. Callback-функция, которая и есть обработчиком.
 *     3. Опции события, например {once: true; ...}.
 */
btns[2].addEventListener('click', () => {
	alert('Клик с помощью метода addEventListener() успешно сработал!');
});
/**
 *  У этого подхода есть один большой плюс – на одно событие можно сразу назначать несколько действий
 *  без побочных эффектов, которые выполнятся по очереди:
 */
btns[2].addEventListener('mouseenter', () => {
	/**
     *  Событие mouseenter – как только курсор мыши попал в область ссылаемого html-элемента,
     *  запускается обработчик.
     */
	alert('Наведение мыши с помощью метода addEventListener() успешно сработало!');
});

/**
 *  !! События в JavaScript выполняются в порядке очереди. Как только поступило новое событие, оно
 *  добавляется в очередь независимо от других событий.
 *  ---
 *  Во время работы иногда необходимо будет получать данные о том элементе, с которым происходит
 *  взаимодействие. Например:
 *  - Какое событие произошло?
 *  - Какой элемент используется?
 *  - Координаты этого элемента и т.д.
 *  Для этого существует специальный объект – event, который имеет свои свойства. Этот объект передаётся
 *  как аргумент в callback-функцию:
 */
btns[3].addEventListener('click', (e) => {
	/**
     *  Объект event как аргумент можно назвать как-угодно, но обычно он носит название 'event', либо же
     *  сокращённо 'e'.
     *  !! Он всегда передаётся первым аргументом. Поэтому, если в обработчик необходимо добавить
     *     другие аргументы, то они записываются только строго после event'a.
     */
	console.log(e); // -> Можно вывести информацию и ознакомиться с очень многими полезными свойствами.

	e.target.remove(); // -> Ссылаясь на target, записанный в объект event, можно удалить его (кнопку) со страницы.
});

/**
 *  Метод removeEventListener() – удалить обработчик событий с определённого элемента.
 *  !! При удалении необходимо использовать точно такую же функцию, которая была назначена при использовании
 *     метода addEventListener(). Это решается с помощью помещения обработчика в отдельную переменную.
 */
let i = 0;
const showBtnCallback = (e) => {
	alert(`Клик по кнопке успешно сработал! Значение: ${i++}`);
	if (i == 1) {
		/**
         *  Обычно метод removeEventListener() как раз вызывается в подобных условиях.
         */
		btns[4].removeEventListener('click', showBtnCallback);
	}
};
btns[4].addEventListener('click', showBtnCallback);

/**
 *  Существует такое важное понятие как "всплытие событий".
 *  ---
 *  Это когда оба элемента – родитель и ребёнок, имеют какой-то общий обработчик событий. При этом изначально
 *  обработчик сработает на дочерний элемент, а уже потом на его родителя/родителей.
 *  ---
 *  Работа по принципу "вверх по иерархии DOM-дерева".
 */
const overlay = document.querySelector('.overlay');
let j = 0;
const showEventHoisting = (e) => {
	console.log(e.target);
	console.log(e.type);
};
overlay.addEventListener('click', showEventHoisting); // -> сработает вторым
btns[5].addEventListener('click', showEventHoisting); // -> сработает первым

/**
 *  JavaScript позволяет отменять стандартное поведение браузера. Есть такие стандартные поведения как
 *  клик по ссылке a.href="...", отправка данных в форме при нажатии на button (с submit), выделение текста и т.д.
 *  ---
 *  Существует два способа для отмены стандартного поведения:
 * 
 *  1) В самом конце обработчика (он же callback-функция) объявить команду return false.
 *     Это устаревший формат, им никто не пользуется.
 * 
 *  2) Использовать метод preventDefault() в начале обработчика. Он ВСЕГДА помещается только в самое начало обработчика
 *     событий.
 */
const link = document.querySelector('a');
link.addEventListener('click', (e) => {
	e.preventDefault(); // -> Благодаря этому методу ссылка не сработает, как и любое другое стандартное поведение браузера.
	console.log(e.target);
});

/**
 *  Как один и тот же обработчик событий правильно присвоить n-ому количеству элементов?
 *  ---
 *  Элементарно, как и в случае иных манипуляций с каждым элементом массива по отдельности – через цикл / метод перебора.
 */
const showAllBtns = (e) => {
	alert('Это сообщение срабатывает по нажатию на каждую зелёную кнопку.');
};
btns.forEach(btn => {
	btn.addEventListener('click', showAllBtns, {once: true});
	/**
     *  Третий необязательный аргумент - это опции события, которые записываются в объект. Их существует достаточно много.
     *  Например, опция {once: true} значит, что обработчик сработает лишь один раз.
     */
});