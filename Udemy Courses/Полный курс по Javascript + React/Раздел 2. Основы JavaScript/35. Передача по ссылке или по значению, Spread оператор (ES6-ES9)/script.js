"use strict";

/**
 *  В этом уроке будет разбор темы, на которой новички делают ошибку: передача данных по ссылке
 *  или по значению.
 */

/**
 *  Когда идёт работа с примитивными типами данных (строки, числа, логические значения), то они
 *  передаются по значению. Именно потому их можно таким простым образом копировать.
 */
let a = 5,
    b = a;

b = b + 5;
console.log(a); // -> 5
console.log(b); // -> 10

/**
 *  С объектами же (в т.ч. массивы, функции, специфические объекты) дела обстоят иначе. Тут идёт
 *  передача не по значению, а по ссылке.
 */
const obj = {
    a: 5,
    b: 1
};
/**
 *  В даном случае, новый объект не создан в переменной copy. Тут передаётся значение по ссылке.
 *  !! Не структура, а лишь ссылка.
 */
const copy = obj;
// Изменяя что-либо внутри ссылок, модифицируется и изначальный объект.
copy.a = 10;
console.log(obj); // -> {a: 10, b: 1}
console.log(copy); // -> {a: 10, b: 1}

/**
 *  Как тогда создавать копии объектов, массивов и т.д.?
 *  Для этого существует несколько способов:
 */

// 1) Использование цикла – при помощи цикла можно создать новый объект методом перебора свойств старого.
function copyFunc(mainObj) {
    let objCopy = {};
    for (let key in mainObj) {
        objCopy[key] = mainObj[key];
    }
    return objCopy;
}
const numbers = { // -> объявление старого объекта
    a: 2,
    b: 5,
    c: {
        x: 7,
        y: 4
    }
};
const newNumbers = copyFunc(numbers); // -> передача результата функции в новую переменную
newNumbers.a = 10; // -> изменение значения нового объекта для наглядности

console.log(numbers); // -> { a: 2, b: 5, c: { x: 7, y: 4 } }
console.log(newNumbers); // -> { a: 10, b: 5, c: { x: 7, y: 4 } }

// Но у этого способа также есть своя особенность
newNumbers.c.x = 10; // При изменении значений во вложенностях нового объекта, результат меняется и в старом объекте :(
console.log(numbers); // -> { c: { x: 10, y: 4 } }
console.log(newNumbers); // -> { c: { x: 10, y: 4 } }

/**
 *  Объясняется это тем, что при клонировании существует 2 понятия:
 *  1) Глубокие копии объектов.
 *  2) Поверхностные копии объектов.
 *  ---
 *  Сейчас речь идёт о поверхностной копии, так как она берёт все обычные свойства, которые были в родителе
 *  и создаёт независимую структуру.
 *  ---
 *  Когда в объекте появляется вложенная структура (объект, массив), то это свойство будет опять
 *  же иметь ссылочный тип данных.
 *  ---
 *  Вывод: изменение по типу данных в этом случае допускается только с теми свойствами, которые лежат у объекта
 *  на первом уровне.
 *  ---
 *  P.S. В течении курса будет показано, как создавать глубокие копии.
 */

// 2) Метод Object.assign() – позволяет соединить сразу несколько объектов.
const add = {
    d: 17,
    e: 20
};
console.log(Object.assign(numbers, add)); // Первый аргумент – куда копировать, второй – что копировать.
/**
 *  Была создана независимая поверхностная копия объекта. Она не зависит не от объекта numbers {}, не от
 *  объекта add {}.
 *  ---
 *  Первым аргументом можно вписать пустой объект {} и тем самым просто создать клон.
 */
console.log(Object.assign({}, add)); // -> { d: 17, e: 20 }

/**
 *  Как создать копию массива?
 *  Для того, чтобы создать массив, можно также пользоваться циклами, но есть и метод.
 *  ---
 *  3) Метод slice() – позволяет скопировать старый массив, можно передавать аргумент по кол-ву элементов, которые
 *  нужно скопировать.
 */
const oldArray = ['a', 'b', 'c'];
const newArray = oldArray.slice();

newArray[1] = 'Quote';
console.log(oldArray); // -> ['a', 'b', 'c']
console.log(newArray); // -> ['a', 'Quote', 'c']

/**
 *  4) Оператор разворота (Spread-оператор) – разворачивает структуру и превращает в набор данных.
 *  Работает как с массивами, так и объектами.
 */
const video = ['youtube', 'vimeo', 'tiktok'],
      blogs = ['wordpress', 'livejournal', 'blogger'],
      internet = [...video, ...blogs, 'facebook', 'instagram']; // ... (три точки) перед переменными просто развернут их в новом массиве
console.log(internet);

// Более сложный пример со Spread-оператором
function log(a, b, c) {
    console.log(a);
    console.log(b);
    console.log(c);
}
const num = [2, 5, 7]; // ~ допустим, что этот массив пришёл с сервера
log(...num);

// Создать копию массива со Spread-оператором
const array = ['a', 'b'];
const secondArray = [...array]; // -> ['a', 'b']

// Создать копию объекта со Spread-оператором
const spreadObj =  {
    one: 1,
    two: 2
};
const newObj = {...spreadObj}; // -> {one: 1, two: 2}

/**
 *  !! Часть нововведений, которые появляются в JavaScript, используются до того, как они были стандартизированы,
 *  в том числе и Spread-оператор (стандартизирован в ES9).
 */