// 1.3. Тур по JavaScript

// Всё, что следует за двумя символами косой черты, является комментарием

// JavaScript поддерживает несколько типов значений:

let a = 1; // числа
let b = 0.01; // числа могут быть целыми и вещественными
let c = "hello world"; // строки текста в кавычках
let d = 'JavaScript'; // одинарные кавычки тоже устанавливают границы строк
let e = true; // булевское значение
let f = false; // другое булевское значение
let g = null; // null - это специальное значение, которое означает отсутствие значения
let h = undefined; // undefined - ещё одно значение, подобное null


// Самым важным типом данных в JavaScript является объект. Объект - это коллекция пар имя/значение
//  или отображений строки на значение:

let book = { // объекты заключаются с фигурные скобки
    topic: "JavaScript", // свойство topic имеет значение JavaScript
    edition: 7          // свойство edition имеет значение 7
};                     // фигурная скобка помечает конец объекта

// Доступ к свойствам объекта осуществляется с помощью . или []:

book.topic // => JavaScript
book["edition"] // => 7: ещё один способ доступа к значениям свойства (менее популярный и удобный)

book.author = "Flanagan"; // новые свойства создаются посредством присваивания
book.contents = {}; // пустой объект, не имеющий свойств


// JavaScript также поддерживает массивы (списки с числовой индексацией) значений:

let primes = [2, 3, 5, 7]; // массив из 4 значений, ограниченный посредством
primes[0]; // => 2: первый элемент (с индексом 0) массива
primes.length // => 4: количество элементов в массиве
primes[primes.length-1] // => 7: последний элемент массива
primes[4] = 9; // с помощью присваивания можно добавлять новые элементы
primes[4] = 11; // с помощью присваивания можнои изменять существующие элементы

let empty = []; // [] - пустой массив, не имеющий элементов
empty.length // => 0

// Массивы и объекты могут содержать другие массивы и объекты

let points = [      // Массив с 2 элементами
    {x: 0, y: 0},   // Каждый элемент является объектом
    {x: 1, y: 1}
];
let data = {                   // Объект с двумя свойствами
    trial1: [[1, 2] [3, 4]],   // Значением каждого свойства является массив
    trial2: [[2, 3] [4, 5]]    // Элементы массива представляют собой массивы
};


// Операции осуществляют действие над значениями (операндами), чтобы произвести новое значение
// Арифметические операции относятся к наиболее простым:

3 + 2 // => 5: сложение
3 - 2 // => 1: вычитание
3 * 2 // => 6: умножение
3 / 2 // => 1.5: деление
points[1].x - points[0].x // => 1: более сложные операнды тоже работают
"3" + "2" // => "32": + выполняет сложение чисел и конкатенацию строк

// В JavaScript определён ряд сокращённых арифметических операций:

let count = 0; // Определение переменной
count++; // Инкрементирование переменной
count--; // Декрементирование переменной
count += 2; // Прибавление 2: то же, что и count = count + 2
count *= 3; // Умножение на 3: то же, что и count = count * 3
count // => 6: имена переменных - тоже выражения


// Операции сравнения проверяют, равны или не равны два значения, больше или меньше одно из них и т.д.
// Результатом будет true или false

let x = 2, y = 3; // Знаки = здесь являются присваиванием, не проверками на равенство
x === y // => false: равенство
x !== y // => true: неравенство
x < y // => true: меньше
x <= y // => true: меньше или равно
x > y // => false: больше
x >= y // => false: больше или равно
"two" === "three" // => false: две строки отличаются друг от друга
"two" > "three" // => true: "tw" в алфавитном порядке больше, чем "th"
false === (x > y) // => true: false равно false

// Логические операции объединяют или инвертируют булевские значения:

(x === 2) && (y === 3) // => true: оба сравнения дают true. && обозначает "и"
(х > 3) || (y < 3) // => false: ни одно из сравнений не даёт true. || обозначает "или"
!(x === y) // => true: ! инвертирует булевское значение


// Функции - это параметризованные блоки кода JavaScript, которые мы можем вызывать

function plus1(x) {   // определить функцию по имени plus1 с параметром x
    return x + 1;     // возвратить значение на единицу больше переданного значения
};
plus1(y) // => 4; y равно 3, так что этот вызов возвращает 3+1

let square = function(x) {  // функции являются значениями и могут присваиваться переменным
    return x * x;           // вычислить значение функции
};                          // точка с запятой помечает конец присваивания
square(plus1(y))            // => 16: вызвать две функции в одном выражении


// Переписываем тот же самый код сверху, только уже стрелочными функциями =>

const plus1 = x => x + 1; // Вход x отображается на выход x + 1
const square = x => x * x; // Вход x отображается на выход x * x
plus1(y) // => 4: вызов функции остаётся прежним
square(plus1(y)) // => 16


// Когда функции присваиваются свойстам объекта, мы называем их "методами"
// Методы имеют все объекты JavaScript (включая массивы):

let a = []; // Создать пустой массив
a.push(1, 2, 3); // Метод push() добавляет элементы в массив
a.reverse(); // Ещё один метод: изменение порядка следования элементов на противоположный

// Мы также можем определять наш собственный метод
// Ключевое слово this ссылается на объект, в котором определяется метод: в данном случае на определённый ранее массив points

points.dist = function() {        // определить метод для расчёта расстояния между точками
    let p1 = this[0];             // первый элемент массива, на котором вызвам метод
    let p2 = this[1];             // второй элемент объекта this
    let a = p2.x-p1.x;            // разность координат x
    let b = p2.y-p1.y;            // разность координат y 
    return Math.sqrt(a*a + b*b);  // теорема Пифагора. Math.sqrt() вычисляет квадратный корень
};
points.dist() // => Math.sqrt(2): расстояние между нашими двумя точками


// JavaScript включает условные операторы и циклы, использующие синтаксис C, C++, Java и других языков

function abs(x) {  // функция для вычисления абсолютной величины
    if (x >= 0) {  // оператор if...
        return x;  // выполняет этот код, если результат сравнения истинный
    }              // конец конструкции if
    else {         // необязательная конструкция else выполняет свой код, если результат сравнения ложный
        return -x;
    }              // когда имеется один оператор на конструкцию, фигурные скобки необязательны
}

abs(-10) === abs(10) // => true


function sum(array) {      // функция для расчёта суммы элементов массива
    let sum = 0;           // начать с исходной суммы 0
    for(let x of array) {  // пройти в цикле по массиву, присваивая каждый элемент переменной x
        sum +=x;           // добавить значение элемента к сумме
    }                      // конец цикла
    return sum;            // возвратить сумму
}
sum(primes)                // => 28: сумма первых 5 простых чисел 2+3+5+7+11


function factorial(n) {    // функция для расчёта факториалов
    let product = 1;       // начать с произведения 1
    while (n > 1) {        // повторять операторы {} до тех пор, пока выражение в () истинно
        product *= n;      // сокращение для product = product * n
        n--;               // сокращение для n = n - 1
    }                      // конец цикла
    return product;        // возвратить произведение
}
factorial(4);              // => 24: 1*4*3*2


function factorial2(n) {                    // ещё одна верия с применением другого цикла
    let i, product = 1;                     // начать с 1
    for (i = 2; i <= n; i++) product *= i;  // автоматически инкрементировать i с 2 до n
                                            // каждый раз делать это. В однострочных циклах скобки не нужны
    return product;                         // возвратить факториал       
}
factorial2(5);                              // => 120: 1*2*3*4*5


// Простой пример, который демонстрирует, как определять класс JavaScript для представления двухмерных геометрических точек

class Point {                                  // по соглашению имена классов начинаются с заглавной буквы
    constructor(x, y) {                        // функция конструктора для инициализации новых экземпляров
        this.x = x;                            // ключевое слово this - это новый инициализируемый объект
        this.y = y;                            // сохранить аргументы функции как свойства объекта
    }                                          // оператор return в функции конструктора не нужен
    distance() {                               // метод для расчёта расстояния от начала координат до точки
        return Math.sqrt (                     // возвратить квадратный корень xI + yI
            this.x * this.x + this.y * this.y  // this ссылается на объект Point, на котором вызван метод distance
        );
    }
}

// Используем функцию конструктора Point() вместе с new для создания объектов Point:
let p = new Point (1, 1); // геометрическая точка (1, 1)

// Теперь используем метод объекта Point по имени p:
p.distance() // Math.SQRT2